defmodule Drab.Client do
  @moduledoc """
  Enable Drab on the browser side. Must be included in HTML template, for example
  in `web/templates/layout/app.html.eex`:

      <%= Drab.Client.run(@conn) %>

  after the line which loads app.js:

      <script src="<%= static_path(@conn, "/js/app.js") %>"></script>

  at the very end of the layout (after template rendering functions).

  ## Own channels inside the Drab's socket
  On the browser side, there is a global object `Drab`, which you may use to create your own channels
  inside Drab Socket:

      ch = Drab.socket.channel("mychannel:whatever")
      ch.join()

  ## Drab JS client API
  ### Drab.connect(token_object)
  Connects to the Drab's websocket. Must be called after injecting JS code with `Drab.Client.generate/2`:

      <%= Drab.Client.generate(@conn) %>
      <script>
        Drab.connect({auth_token: window.my_token});
      </script>


  ### Drab.exec_elixir(elixir_function_name, argument)
  Run elixir function (which must be a handler in the commander) from the browser side.

  Arguments:
  * elixir_function_name(string) - function name
  * argument(object) - the object will be passed to the handler function as a map

  Function name may be given with the commander name, like "MyApp.MyCommander.handler_function", or the function
  name only: "handler_function". In this case the corresponding commander module will be used.

  When running the handler from the page generated by the other controller, this function must be marked
  as public with `Drab.Commander.public/1` macro.

  Returns:
  * no return, does not wait for any answer

  Example:

      <button onclick="Drab.exec_elixir('clicked', {click: 'clickety-click'});">
        Clickme
      </button>

  The code above runs function named `clicked` in the corresponding Commander, with
  the argument `%{"click" => "clickety-click}"`
  """

  import Drab.Template
  require Logger

  @doc """
  Generates JS code and runs Drab.

  Passes controller and action name, tokenized for safety. Works only when the controller, which renders
  the current action has been compiled with `use Drab.Controller`.

  Optional argument may be a list of parameters which will be added to assigns to the socket.
  Example of `layout/app.html.eex`:

      <%= Drab.Client.run(@conn) %>
      <%= Drab.Client.run(@conn, user_id: 4, any_other: "test") %>

  Please remember that your parameters are passed to the browser as Phoenix Token. Token is signed,
  but not ciphered. Do not put any secret data in it.
  """
  def run(conn, assigns \\ []) do
    generate_drab_js(conn, true, assigns)
  end

  @doc false
  def js(conn, assigns \\ []) do
    Deppie.warn("""
    Drab.Client.js/2 is depreciated.
    Please use Drab.Client.run/2 or Drab.client.generate/2 instead.
    """)

    run(conn, assigns)
  end

  @doc """
  Like `run/2`, but does not connect to the Drab socket.

  It is intended to use when you need to pass the additional tokens, eg. for authorization. To connect,
  use `Drab.connect(object)` JS function.

      <script>
        window.my_token = ...
      </script>
      <%= Drab.Client.generate(@conn) %>
      <script>
        Drab.connect({auth_token: window.my_token});
      </script>

  Like in `run/2`, you may use optional arguments, which will become socket's assigns.

  Please check `Drab.Socket` for more information about how to handle the auth tokens with Drab.
  """
  def generate(conn, assigns \\ []) do
    generate_drab_js(conn, false, assigns)
  end

  defp generate_drab_js(conn, connect?, assigns) do
    controller = Phoenix.Controller.controller_module(conn)
    # Enable Drab only if Controller compiles with `use Drab.Controller`
    # in this case controller contains function `__drab__/0`
    if Enum.member?(controller.__info__(:functions), {:__drab__, 0}) do
      controller_and_action =
        Phoenix.Token.sign(
          conn,
          "controller_and_action",
          __controller: controller,
          __action: Phoenix.Controller.action_name(conn),
          __assigns: assigns
        )

      commander = controller.__drab__()[:commander]
      broadcast_topic = topic(commander.__drab__().broadcasting, controller, conn.request_path)

      templates = DrabModule.all_templates_for(commander.__drab__().modules)

      access_session = commander.__drab__().access_session

      session =
        access_session
        |> Enum.map(fn x -> {x, Plug.Conn.get_session(conn, x)} end)
        |> Enum.into(%{})

      session_token = Drab.Core.tokenize_store(conn, session)

      bindings = [
        controller_and_action: controller_and_action,
        commander: commander,
        templates: templates,
        drab_session_token: session_token,
        broadcast_topic: broadcast_topic,
        connect: connect?
      ]

      js = render_template("drab.js", bindings)

      Phoenix.HTML.raw("""
      <script>
        #{js}
      </script>
      """)
    else
      ""
    end
  end

  # defp topic(:all, _, _), do: "all"
  defp topic(:same_path, _, path), do: Drab.Core.same_path(path)
  defp topic(:same_controller, controller, _), do: Drab.Core.same_controller(controller)
  defp topic(topic, _, _) when is_binary(topic), do: Drab.Core.same_topic(topic)
end
