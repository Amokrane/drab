defmodule Drab do
  require Logger

  @moduledoc """
  Drab allows to query and manipulate the User Interface directly from the Phoenix server backend.

  To enable it on the specific page you must find its controller and 
  enable Drab by `use Drab.Controller` there:

      defmodule DrabExample.PageController do
        use Example.Web, :controller
        use Drab.Controller 

        def index(conn, _params) do
          render conn, "index.html"
        end
      end   

  Notice that it will enable Drab on all the pages generated by `DrabExample.PageController`.

  All Drab functions (callbacks and event handlers) should be placed in a module called 'commander'. It is very
  similar to controller, but it does not render any pages - it works with the live page instead. Each controller with 
  enabled Drab should have the corresponding commander.

      defmodule DrabExample.PageCommander do
        use Drab.Commander, onload: :page_loaded

        # Drab Callbacks
        def page_loaded(socket) do
          socket |> update(:html, set: "Welcome to Phoenix+Drab!", on: "div.jumbotron h2")
          socket |> update(:html, 
                set: "Please visit <a href='https://tg.pl/drab'>Drab</a> page for more examples and description",
                on:  "div.jumbotron p.lead")
        end

        # Drab Events
        def button_clicked(socket, dom_sender) do
          socket |> update(:text, set: "alread clicked", on: this(dom_sender))
        end

      end

  Drab treats browser page as a database, allows you to read and change the data there. Please refer to `Drab.Query` documentation to 
  find out how `Drab.Query.select/2` or `Drab.Query.update/2` works.

  ## Modules

  Drab is modular. You my choose which modules to use in the specific Commander by using `:module` option
  in `use Drab.Commander` directive. By default, `Drab.Query` and `Drab.Modal` are loaded, but you may override it using 
  options with `use Drab.Commander` directive.

  Every module must have the corresponding javascript template, which is added to the client code in case the module is loaded.
  """

  use GenServer

  @doc false
  def start({store, channel_pid, commander}) do
    GenServer.start(__MODULE__, {store, channel_pid, commander})
  end

  def start_link({store, channel_pid, commander}) do
    GenServer.start_link(__MODULE__, {store, channel_pid, commander})
  end

  @doc false
  def init({store, channel_pid, commander}) do
    # Drab Closing Waiter handles disconnects, when websocket dies
    # TODO: learn about GenServer init. I set up :drab_pid here and in Drab.Channel.join
    # I set up it here because it need to exists before join...???
    # socket_with_my_pid = Phoenix.Socket.assign(socket, :drab_pid, self())
    # commander(socket).__drab_closing_waiter__(socket_with_my_pid)
    # {:ok, socket_with_my_pid}
    # Process.flag(:trap_exit, true)
    Logger.debug("Drab pid: #{inspect(self())}, channel pid: #{inspect(channel_pid)}")
    if Process.alive?(channel_pid) do
      Process.monitor(channel_pid)
    else
      Logger.error("Socket died before starting Drab process.")
      Process.exit(self(), :normal)
    end
    {:ok, {store, commander}}
  end

  def handle_info({:DOWN, _ref, :process, _pid, {_reason, _state}}, {store, commander}) do
    Logger.debug(store|>inspect)
    if commander.__drab__().ondisconnect do
      # TODO: timeout
      :ok = apply(commander, 
            commander.__drab__().ondisconnect, 
            [store])
    end
    # TODO: rething the processes strategy
    Process.exit(self(), :normal)
    {:noreply, {store, commander}}
  end

  @doc false
  def handle_cast({:onload, socket}, {_store, commander}) do
    # socket is coming from the first request from the client
    onload = drab_config(commander).onload
    returned_socket = if onload do # only if onload exists
      apply(commander, onload, [socket])
    else
      socket
    end
    Phoenix.Channel.push(socket, "event", %{
      drab_store_token: drab_store_token(socket, returned_socket)
    })
    #TODO: update store in Drab server
    {:noreply, {returned_socket.assigns.drab_store, commander}}
  end

  @doc false
  def handle_cast({:onconnect, socket}, {_store, commander}) do
    onconnect = drab_config(commander).onconnect
    returned_socket = if onconnect do
      apply(commander, onconnect, [socket])
    else
      socket
    end
    Phoenix.Channel.push(socket, "event", %{
      drab_store_token: drab_store_token(socket, returned_socket)
    })
    #TODO: update store in Drab server
    {:noreply, {returned_socket.assigns.drab_store, commander}}
  end

  @doc false
  def handle_cast({:update_store, store}, {_store, commander}) do
    # Logger.debug("UPDATED, #{inspect(updated_socket)}")
    {:noreply, {store, commander}}
  end

  @doc false
  # any other cast is an event handler
  def handle_cast({_, socket, payload, event_handler_function, reply_to}, {store, commander}) do
    do_handle_cast(socket, event_handler_function, payload, reply_to, store, commander)
  end

  defp do_handle_cast(socket, event_handler_function, payload, reply_to, store, commander) do
    commander_module = commander

    # raise a friendly exception when misspelled the function handler name
    unless function_exists?(commander_module, event_handler_function) do
      raise "Drab can't find the event handler function \"#{commander_module}.#{event_handler_function}/2\"."
    end

    # TODO: rethink the subprocess strategies - now it is just spawn_link
    spawn_link fn -> 
      dom_sender = Map.delete(payload, "event_handler_function")
      returned_socket = apply(
        commander_module, 
        String.to_existing_atom(event_handler_function), 
        [socket, dom_sender]
      )

      #TODO: check if handler returned real socket, otherwise push will crash

      # Send a message to browser to run the "after event" callback
      # eg. for enabling the buttons after handling events
      Phoenix.Channel.push(returned_socket, "event", %{
        finished: reply_to,
        drab_store_token: drab_store_token(socket, returned_socket)
      })

      # Logger.debug("**** DRAB.socket: #{inspect(Drab.get_socket(returned_socket.assigns.drab_pid))}")

      # Drab.update_store(returned_socket.assigns.drab_pid, returned_socket)
      # GenServer.cast(returned_socket.assigns.drab_pid, {:update_store, returned_socket.assigns.drab_store})
      Drab.update_store(returned_socket.assigns.drab_pid, returned_socket.assigns.drab_store)
    end

    {:noreply, {store, commander}}
  end

  @doc false
  def get_store(pid) do
    GenServer.call(pid, :get_store)
  end

  def update_store(pid, new_store) do
    GenServer.cast(pid, {:update_store, new_store})
  end

  @doc false
  def handle_call(:get_store, _from, store) do
    {:reply, store, store}
  end

  defp drab_store_token(socket, returned_socket) do
    # check if the handler return socket, if not - ignore
    # TODO: change the warning to exception
    updated_store = case returned_socket do
      %Phoenix.Socket{assigns: returned_assigns} ->
        returned_assigns.drab_store
      ret ->
        Logger.warn("Event Handler should return `socket`. It returned: `#{inspect(ret)}` instead. Drab Store will not be updated.")
        socket.assigns.drab_store
    end
    Phoenix.Token.sign(socket, "drab_store_token",  updated_store)
  end

  defp function_exists?(module_name, function_name) do
    module_name.__info__(:functions) 
      |> Enum.map(fn {f, _} -> Atom.to_string(f) end)
      |> Enum.member?(function_name)
  end

  @doc false
  def push_and_wait_for_response(socket, pid, message, options \\ []) do
    push(socket, pid, message, options)
    receive do
      {:got_results_from_client, reply} ->
        reply
    # TODO: timeout
    end    
  end

  @doc false
  def push(socket, pid, message, options \\ []) do
    do_push_or_broadcast(socket, pid, message, options, &Phoenix.Channel.push/3)
  end

  @doc false
  def broadcast(socket, pid, message, options \\ []) do
    do_push_or_broadcast(socket, pid, message, options, &Phoenix.Channel.broadcast/3)
  end

  defp do_push_or_broadcast(socket, pid, message, options, function) do
    m = options |> Enum.into(%{}) |> Map.merge(%{sender: tokenize(socket, pid)})
    function.(socket, message,  m)
  end

  @doc false
  def tokenize(socket, pid) do
    myself = :erlang.term_to_binary(pid)
    Phoenix.Token.sign(socket, "sender", myself)
  end

  # returns the commander name for the given controller (assigned in token)
  @doc false
  def get_commander(socket) do
    # Logger.debug "**** ASSIGNS: #{inspect(socket.assigns)}"
    controller = socket.assigns.controller
    controller.__drab__()[:commander]
  end

  # if module is commander or controller with drab enabled, it has __drab__/0 function with Drab configuration
  defp drab_config(module) do
    module.__drab__()
  end

  @doc """
  Returns map of Drab configuration options.
  
  All the config values may be override in `config.exs`, for example:

      config :drab, disable_controls_while_processing: false

  Configuration options:
  * `disable_controls_while_processing` (default: `true`) - after sending request to the server, sender will be 
    disabled until get the answer; warning: this behaviour is not broadcasted, so only the control in the current
    browers will be disabled
  * `events_to_disable_while_processing` (default: `["click"]`) - list of events which will be disabled when 
    waiting for server response
  * `disable_controls_when_disconnected` (default: `true`) - disables control when there is no connectivity
    between the browser and the server
  * `socket` (default: `"/drab/socket"`) - path to Drab socket
  """
  def config() do
    %{
      disable_controls_while_processing: Application.get_env(:drab, :disable_controls_while_processing, true),
      events_to_disable_while_processing: Application.get_env(:drab, :events_to_disable_while_processing, ["click"]),
      disable_controls_when_disconnected: Application.get_env(:drab, :disable_controls_when_disconnected, true),
      socket: Application.get_env(:drab, :socket, "/drab/socket")
    }
  end
end
